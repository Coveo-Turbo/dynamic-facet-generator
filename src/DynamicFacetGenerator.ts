import {
  Component,
  ComponentOptions,
  IComponentBindings,
  QueryEvents,
  IBuildingQueryEventArgs,
  DynamicFacet,
  $$,
  IFieldOption,
  get,
  DynamicHierarchicalFacet,
  LocalStorageUtils,
  QueryStateModel,
} from 'coveo-search-ui';
import { last, isFunction } from 'underscore';
import { ComponentsTypes } from './utilities/ComponentsTypes';
import { CustomEvents } from './events/CustomEvents';
import { UrlUtils } from './utilities/UrlUtils';

import { lazyComponent } from '@coveops/turbo-core';

export interface IFacetDictionary {
  [value: string]: string[];
}

export interface IFacetTransformArgs {
  facetTitle: string;
  field: string;
}

export interface IDynamicFacetGeneratorOptions {
  allowedFields?: IFieldOption[];
  dependsOn?: string;
  useCache?: boolean;
  getDictionaryPromise: () => Promise<IFacetDictionary>;
  transformer?: (value: string) => IFacetTransformArgs;
  dictionary?: IFacetDictionary;
}

@lazyComponent
/**
 * Dynamically generates facets when a condition is met
 *
 * @export
 * @class DynamicFacetGenerator
 * @extends {Component}
 * @implements {IComponentBindings}
 */
export class DynamicFacetGenerator extends Component implements IComponentBindings {
  static ID = 'DynamicFacetGenerator';

  private dictionary: IFacetDictionary = null;
  private previousSelectedCategory: string = null;
  private localStorage: LocalStorageUtils<{ [caption: string]: string[] }>;

  static options: IDynamicFacetGeneratorOptions = {
    useCache: ComponentOptions.buildBooleanOption({ defaultValue: false }),
    allowedFields: ComponentOptions.buildListOption<string>(),
    /**
     * Specifies a dictionary with
     * To specify the parent facet, use its id.
     */
    dictionary: ComponentOptions.buildJsonOption(),
    /**
     * Specifies whether this facet only appears when a value is selected in its "parent" facet.
     * To specify the parent facet, use its id.
     */
    dependsOn: ComponentOptions.buildStringOption<string>(),
    transformer: ComponentOptions.buildCustomOption<(value: string) => IFacetTransformArgs>(() => null),
    getDictionaryPromise: ComponentOptions.buildCustomOption<() => Promise<IFacetDictionary>>(() => {
      return null;
    }),
  };

  /**
   * Creates a new `Fleetpride` component.
   * @param element The HTMLElement on which to instantiate the component.
   * @param options The options for the `ResultList` component.
   * @param bindings The bindings that the component requires to function normally. If not set, these will be
   * automatically resolved (with a slower execution time).
   */
  constructor(public element: HTMLElement, public options: IDynamicFacetGeneratorOptions, public bindings: IComponentBindings) {
    super(element, DynamicFacetGenerator.ID, bindings);
    this.options = ComponentOptions.initComponentOptions(element, DynamicFacetGenerator, options);

    this.bind.onRootElement(QueryEvents.buildingQuery, (args: IBuildingQueryEventArgs) => this.handleBuildingQuery(args));

    this.init();
  }

  updateDictionary(dictionary: IFacetDictionary) {
    this.dictionary = dictionary;
  }

  /**
   * Clears all current Dynamic Facets that have generated by this component
   *
   */
  clearGeneratedFacet() {
    if (this.element.children) {
      let rescueCounter = 1000; // In case it goes into an infinite loop. It is unlikely, but just in case...
      while (this.element.firstChild && rescueCounter > 0) {
        rescueCounter--;
        const child = this.element.firstChild as HTMLElement;
        if (child) {
          const facet = get(child, 'DynamicFacet') as DynamicFacet;
          if (facet) {
            // Disabling the Facet
            facet.disable();
            // Removing the Facet element from the DOM
            this.element.removeChild(child);
            const existingFacet: DynamicFacet[] = this.componentStateModel.attributes[QueryStateModel.getFacetId(facet.options.id)];
            if (existingFacet && existingFacet.length) {
              // Even if we disable the Facet component and remove the HTML element form the DOM, it will continue to exist in the componentStateModel. So we need to manually remove it from the state.
              this.componentStateModel.attributes[QueryStateModel.getFacetId(facet.options.id)] = [];
            }
          }
        }
      }
    }
  }

  private init() {
    // First check if a dictionnary has been passed as an option
    this.dictionary = this.options.dictionary;

    if (this.dictionary == null) {
      if (this.options.useCache) {
        this.initLocalStorage();
        this.loadDictionaryFromCache();
      }

      // If there is nothing in the cache and the dictionary is still null, load from async method
      if (this.dictionary == null) {
        this.fetchDictionaryAsync();
      }
    }
  }

  private initLocalStorage() {
    this.localStorage = new LocalStorageUtils<{ [caption: string]: string[] }>(DynamicFacetGenerator.ID);
  }

  private isParentAHierarchyFacet(): boolean {
    return this.getParentFacet()?.type === DynamicHierarchicalFacet.ID;
  }

  /**
   * Tries to load the dictionary from the Local Storage
   *
   * @private
   */
  private loadDictionaryFromCache() {
    this.logger.debug('Loading dictionary from cache');
    this.dictionary = this.localStorage.load();
  }

  /**
   * Tries to load the dictionary from an async method provided as an option
   *
   * @private
   */
  private fetchDictionaryAsync() {
    if (this.options.getDictionaryPromise) {
      this.options
        .getDictionaryPromise()
        .then((dict) => {
          this.dictionary = dict;
          if (this.options.useCache) {
            this.logger.debug('Saving dict into local storage');
            this.localStorage.save(dict);
          }

          if (this.getAllowedFacets(this.getCurrentSelectedParentValue())) {
            // Do not reload the search if the parent facet is not selected
            this.reloadSearch();
          }
        })
        .catch((err) => {
          this.logger.error('Unable to fetch dictionary', err);
        });
    }
  }

  /**
   * Reloads the results by executing a search query. This method will only be called in the callback of the async method.
   *
   * @private
   */
  private reloadSearch() {
    this.queryController.executeQuery({
      beforeExecuteQuery: () => this.logCustomEvent(CustomEvents.updateFacetDictionary),
      ignoreWarningSearchEvent: true,
      logInActionsHistory: false,
    });
  }

  private logCustomEvent(eventName: string) {
    this.usageAnalytics.logCustomEvent({ name: eventName, type: 'customEventType' }, {}, this.root);
  }

  /**
   * Get the parent Facet to drive the generation of dynamic Facets
   *
   * @private
   * @returns {Component}
   */
  private getParentFacet(): Component {
    const masterFacetComponent = ComponentsTypes.getAllFacetInstancesFromElement(this.root).filter((cmp: Component) => {
      const idFacet = _.reduce(ComponentsTypes.allFacetsType, (memo, type) => cmp instanceof type || memo, false);
      return idFacet && cmp.options.id === this.options.dependsOn;
    }) as Component[];

    if (!masterFacetComponent.length) {
      this.logger.warn(
        `Unable to find a Facet with the id or field "${this.options.dependsOn}".`,
        `The master facet values can't be updated.`
      );
      return;
    }
    if (masterFacetComponent.length > 1) {
      this.logger.warn(
        `Multiple facets with id "${this.options.dependsOn}" found.`,
        `A given facet may only depend on a single other facet.`,
        `Ensure that each facet in your search interface has a unique id.`,
        masterFacetComponent
      );
      return;
    }
    return masterFacetComponent[0];
  }

  /**
   * Generate the Facets passed as parameters
   *
   * @private
   * @param {IFacetTransformArgs[]} facets to generate
   */
  private generateFacets(facets: IFacetTransformArgs[]) {
    facets.map((facet) => {
      const element = $$('div');
      this.element.appendChild(element.el);
      const generatedFacet = new DynamicFacet(element.el, { field: facet.field, title: facet.facetTitle });
      this.ensureFacetState(generatedFacet);
    });
  }

  /**
   * This is required to update the generated facets based on the state. Since they are generated at a later stage, they cannot listen to state change. This method ensures the state of every dynamically generated facet is preserved and correctly handled
   *
   * @private
   * @param {DynamicFacet} facet
   */
  private ensureFacetState(facet: DynamicFacet) {
    // First read the url
    const params = UrlUtils.getUrlParams(location.href);
    const facetId = QueryStateModel.getFacetId(facet.options.id);

    // check if the facet state is consistent between the url and the component
    // This is required because the facets are generated too late
    if (params && params[facetId] && params[facetId] !== JSON.stringify(this.queryStateModel.attributes[facetId])) {
      // if there is a facet value selected in the state but not in the UI.
      // This happens because the facets could be generated dynamically at any moment
      try {
        const values = _.toArray(params[facetId]).slice(1, -1).join('').split(',');
        if (values) {
          // There is a facet value in the url that is not saved into the state
          facet.selectMultipleValues(values);
        }
      } catch (error) {
        this.logger.error('Unable to parse facet state in the url', params[facetId]);
      }
    }
  }

  private updateDynamicFacetAppareance() {
    const selectedCategory = this.getCurrentSelectedParentValue();

    if (selectedCategory !== this.previousSelectedCategory) {
      // Do not clear if same parent selected
      this.clearGeneratedFacet();

      // Do not regenerate facets if parent facet has not changed
      const facets = this.getAllowedFacets(selectedCategory);
      if (facets && facets.length > 0) {
        if (isFunction(this.options.transformer)) {
          this.generateFacets(facets.map((facet) => this.options.transformer(facet)));
        } else {
          this.logger.error('transformer option is not defined');
        }
      }

      this.previousSelectedCategory = selectedCategory;
    }
  }

  /**
   * Returns the approrpiate Facets names based on the selected parent value.
   *
   * @private
   * @param {string} key selected parent value. Should be a key in the dictionary
   * @returns {string[]} Facet names
   */
  private getAllowedFacets(key: string): string[] {
    return this.dictionary ? this.dictionary[key] : null;
  }

  /**
   * Get the current selected value on the parent Facet
   *
   * @private
   * @returns {(string | null)} The parent selected value or null if no value is found
   */
  private getCurrentSelectedParentValue(): string | null {
    const facetAttributes = this.queryStateModel.attributes[QueryStateModel.getFacetId(this.options.dependsOn)] as string[];

    if (facetAttributes) {
      return facetAttributes.length > 0 ? (this.isParentAHierarchyFacet() ? last(facetAttributes) : facetAttributes[0]) : null;
    } else {
      this.logger.warn('Unable to find facet attribute', this.options.dependsOn);
      return null;
    }
  }

  private handleBuildingQuery(args: IBuildingQueryEventArgs) {
    if (this.dictionary && this.getParentFacet()) {
      this.updateDynamicFacetAppareance();
    }
  }
}
